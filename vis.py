import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from matplotlib.widgets import Slider
from scipy.optimize import minimize

def interp(i, k, t, knots):
    tol = 1e-6

    if k == 0:
        if (knots[i] <= t + tol) and (t - tol < knots[i+1]):
            return 1.0
        else:
            return 0.0
    
    denom1 = knots[i+k] - knots[i]
    denom2 = knots[i+k+1] - knots[i+1]
    c1 = 0.0 if denom1 < tol else (t - knots[i]) / denom1
    c2 = 0.0 if denom2 < tol else (knots[i+k+1] - t) / denom2

    return c1 * interp(i, k-1, t, knots) + c2 * interp(i+1, k-1, t, knots)

def eval(u, v, control_points, u_knots, v_knots, p, q, weights=None):
    nu, nv, _ = control_points.shape
    
    # if no weights provided, default to uniform weights (standard B-spline)
    if weights is None:
        weights = np.ones((nu, nv))
    
    # compute rational basis (NURBS)
    numerator = np.zeros(3)
    denominator = 0.0
    
    for i in range(nu):
        for j in range(nv):
            N = interp(i, p, u, u_knots)
            M = interp(j, q, v, v_knots)
            w = weights[i, j]
            basis_weighted = N * M * w
            numerator += basis_weighted * control_points[i, j]
            denominator += basis_weighted
    
    # rational divide
    return numerator / denominator if denominator != 0 else np.zeros(3)

def find_uv_for_xy(target_x, target_y, control_points, u_knots, v_knots, p, q, weights=None, initial_guess=None):
    """
    Find (u, v) parameters where the NURBS surface intersects a vertical ray from (x, y, -inf).
    
    This solves: minimize ||surface(u,v)[:2] - [target_x, target_y]||^2
    
    Args:
        target_x, target_y: x,y coordinates of the ray
        control_points, u_knots, v_knots, p, q, weights: NURBS surface parameters
        initial_guess: optional (u0, v0) starting point, defaults to (0.5, 0.5)
    
    Returns:
        result dict with:
            'u', 'v': optimized parameters
            'point': 3D point on surface at (u,v)
            'success': whether optimization converged
            'error': distance from target in xy plane
    """
    if initial_guess is None:
        initial_guess = [0.5, 0.5]
    
    def objective(uv):
        u, v = uv
        # clamp to valid parameter range [0, 1]
        u = np.clip(u, 0.0, 1.0)
        v = np.clip(v, 0.0, 1.0)
        pt = eval(u, v, control_points, u_knots, v_knots, p, q, weights)
        dx = pt[0] - target_x
        dy = pt[1] - target_y
        return dx*dx + dy*dy
    
    # optimize with bounds
    result = minimize(objective, initial_guess, method='L-BFGS-B', 
                     bounds=[(0, 1), (0, 1)])
    
    u_opt, v_opt = result.x
    point = eval(u_opt, v_opt, control_points, u_knots, v_knots, p, q, weights)
    error = np.sqrt(objective([u_opt, v_opt]))
    
    return {
        'u': u_opt,
        'v': v_opt,
        'point': point,
        'success': result.success,
        'error': error
    }

# degrees
p, q = 3, 3

# control points grid (shape: (nu, nv, 3))
control_points = np.array([
    [[0, 0, 0], [0, 1, 0  ], [0, 2, 0  ], [0, 3, 0]],
    [[1, 0, 0], [1, 1, 0.2], [1, 2, 0.1], [1, 3, 0]],
    [[2, 0, 0], [2, 1, -0.5], [2, 2, 0.3], [2, 3, 0]],
    [[3, 0, 0], [3, 1, 0  ], [3, 2, 0  ], [3, 3, 0]],
])

# knot vectors
u_knots = np.array([0, 0, 0, 0, 1, 1, 1, 1])  # open uniform
v_knots = np.array([0, 0, 0, 0, 1, 1, 1, 1])

# weights grid (shape: (nu, nv)) - vary weights to demonstrate NURBS behavior
weights = np.ones((4, 4))
# increase weight at center control points to "pull" surface toward them
weights[1, 1] = 2.0
weights[1, 2] = 2.0
weights[2, 1] = 2.0
weights[2, 2] = 2.0

x = np.linspace(0, 1, 100)
y = np.linspace(0, 1, 100)
points = np.array([[eval(u, v, control_points, u_knots, v_knots, p, q, weights) for v in y] for u in x])


fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
scat = ax.scatter(points[:,:,0], points[:,:,1], points[:,:,2], c='b', marker='o', s=1)
ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('Z')

# plot control points
cp_x = control_points[:,:,0].flatten()
cp_y = control_points[:,:,1].flatten()
cp_z = control_points[:,:,2].flatten()
ax.scatter(cp_x, cp_y, cp_z, c='r', marker='^', s=50, label='Control points')

# load in vectors from test/surf_0_normal.txt
'''
Generated by:
for (int i = 0; i < 11; i++) {
    for (int j = 0; j < 11; j++) {
        float u = (float) i / 10.0f;
        float v = (float) j / 10.0f;
        fv3_t n = surf.get_normal(u, v);
        fprintf(out, "%f,%f,%f\n", n.data[0], n.data[1], n.data[2]);
    }
}
'''
normals = np.loadtxt('test/norm_0.txt', delimiter=',').reshape((17, 17, 3))
# plot normals as arrows
for i in range(17):
    for j in range(17):
        u = i / 16.0
        v = j / 16.0
        pt = eval(u, v, control_points, u_knots, v_knots, p, q, weights)
        n = normals[i, j]
        ax.quiver(pt[0], pt[1], pt[2], n[0], n[1], n[2], length=0.2, color='g', normalize=True)

# plot against locally generated truth normals

def surface_normal(u, v, control_points, u_knots, v_knots, p, q, weights=None, epsilon=1e-6):
    """
    fv3_t NurbSurf::get_normal(float t_x, float t_y) {
    float epsilon = 1e-7f;
    fv3_t ur = get_point(t_x + epsilon, t_y);
    fv3_t ul = get_point(t_x - epsilon, t_y);
    fv3_t vr = get_point(t_x, t_y + epsilon);
    fv3_t vl = get_point(t_x, t_y - epsilon);

    fv3_t du = (ur + ul) * (1.0f / (2.0f * epsilon));
    fv3_t dv = (vr + vl) * (1.0f / (2.0f * epsilon));

    fv3_t normal(
        du.data[1] * dv.data[2] - du.data[2] * dv.data[1],
        du.data[2] * dv.data[0] - du.data[0] * dv.data[2],
        du.data[0] * dv.data[1] - du.data[1] * dv.data[0]
    );
    
    return normal;
    }
    """
    ur = eval(u + epsilon, v, control_points, u_knots, v_knots, p, q, weights)
    ul = eval(u - epsilon, v, control_points, u_knots, v_knots, p, q, weights)
    vr = eval(u, v + epsilon, control_points, u_knots, v_knots, p, q, weights)
    vl = eval(u, v - epsilon, control_points, u_knots, v_knots, p, q, weights)

    du = (ur - ul) / (2.0 * epsilon)
    dv = (vr - vl) / (2.0 * epsilon)

    normal = np.array([
        du[1] * dv[2] - du[2] * dv[1],
        du[2] * dv[0] - du[0] * dv[2],
        du[0] * dv[1] - du[1] * dv[0]
    ])
    
    norm_length = np.linalg.norm(normal)
    if norm_length < 1e-6:
        return np.array([0.0, 0.0, 0.0])
    return normal / norm_length

# for i in range(11):
#     for j in range(11):
#         u = i / 10.0
#         v = j / 10.0
#         pt = eval(u, v, control_points, u_knots, v_knots, p, q, weights)
#         n = surface_normal(u, v, control_points, u_knots, v_knots, p, q, weights)
#         ax.quiver(pt[0], pt[1], pt[2], n[0], n[1], n[2], length=0.2, color='k', normalize=True)

# rescale each axis equally
max_range = np.array([points[:,:,0].max()-points[:,:,0].min(), points[:,:,1].max()-points[:,:,1].min(), points[:,:,2].max()-points[:,:,2].min()]).max() / 2.0
mid_x = (points[:,:,0].max()+points[:,:,0].min()) * 0.5
mid_y = (points[:,:,1].max()+points[:,:,1].min()) * 0.5
mid_z = (points[:,:,2].max()+points[:,:,2].min()) * 0.5
ax.set_xlim(mid_x - max_range, mid_x + max_range)
ax.set_ylim(mid_y - max_range, mid_y + max_range)
ax.set_zlim(mid_z - max_range, mid_z + max_range)

ax.legend()
plt.show()
